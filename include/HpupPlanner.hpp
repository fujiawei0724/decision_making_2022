/*
 * @Date: 2021-12-12 16:51:30
 * @LastEditors: fujiawei0724
 * @LastEditTime: 2021-12-12 21:10:02
 * @Description: Realization of the HPUP behavior planner based on reinforcement learning.
 */

#pragma once


#include "Const.hpp"
#include "VehicleState.hpp"

namespace HpupPlanner {

using namespace Common;

/**
 * @brief transform vehicles state and lanes information to state 
 * @param ref_lane reference_lane for ego_vehicle
 * @return {*}
 */
class StateInterface {
 public:
    StateInterface(const Lane& ref_lane) {
        stf_ = new StateTransformer(ref_lane);
    }
    StateInterface() = default;
    ~StateInterface() = default;

    /**
     * @brief generate state from environment information
     * @param {Vehicle&} ego_vehicle
     */
    void runOnce(const std::array<std::pair<bool, double>, 2>& lane_info, const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& sur_vehicles, std::vector<double>* state) {

    }

    /**
     * @brief transform single vehicle state
     * @param {*}
     * @return {*}
     */    
    std::vector<double> transformSingleVehicleState(const Vehicle& vehicle) {

    }

    /**
     * TODO: maybe a logic could be added here to distinct the differerce of different surround vehicles
     * @brief transform surround vehicles states
     * @param {*}
     * @return {*}
     */    
    std::vector<double> transformSurroundVehicleState(const std::unordered_map<int, Vehicle>& sur_vehicles) {
        
    }



    StateTransformer* stf_{nullptr};
    
};

// Interface with libtorch
class TorchInterface {
 public:
    TorchInterface(const std::string& model_path) {
        model_path_ = model_path;
    }
    ~TorchInterface() = default;

    /**
     * @brief generate best action index from forwarding model
     * @param state state inputed to the model
     * @param action_index action generated by model
     */    
    void runOnce(const std::vector<double>& state, int* action_index) {
        // Load model
        torch::jit::script::Module module = torch::jit::load(model_path_);

        // Convert data
        torch::Tensor state_tensor = torch::tensor(state).unsqueeze(0);
        std::vector<torch::jit::IValue> inputs;
        inputs.emplace_back(state_tensor);
        
        // Forward 
        torch::Tensor pred_res = module.forward(inputs).toTensor();
        torch::Tensor pred_action = torch::argmax(pred_res, 1).squeeze();
        auto* index = pred_action.data_ptr<long>();
        int int_index = static_cast<int>(*index);
        
        // Cache
        *action_index = int_index;
    }

    std::string model_path_;
};

} // End of namespace HpupPlanner
