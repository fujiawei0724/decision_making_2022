/*
 * @Author: fujiawei0724
 * @Date: 2021-12-12 16:51:30
 * @LastEditors: fujiawei0724
 * @LastEditTime: 2022-09-25 20:02:07
 * @Description: Realization of the HPDM behavior planner based on reinforcement learning.
 */

#pragma once


#include "Const.hpp"
#include "VehicleState.hpp"
#include "BehaviorPlanner.hpp"
#include "ObservationBuffer.hpp"

namespace HpdmPlanner {

using namespace Common;

class ActionInterface {
 public:
    /**
     * TODO: only support predicted time 4.0s with a time gap 0.4s, add more support parameters here
     * @brief transform an action index to a behavior sequence
     * @param action_index action index generate by model
     * @return behavior sequence
     */    
    static std::vector<VehicleBehavior> indexToBehSeq(const int& action_index);

    /**
     * @brief transform a series of action indices
     * @param action_indices a list of action index
     * @return {*}
     */   
    static std::vector<std::vector<VehicleBehavior>> indexVecToBehSeqVec(const std::vector<int>& action_indices);

    /**
     * TODO: only support predicted time 4.0s with a time gap 0.4s, add more support parameters here
     * @brief transform an action index to a intention sequence
     * @param action_index action index generate by model
     * @return intention sequence
     */    
    static std::vector<VehicleIntention> indexToIntentionSeq(const int& action_index);

    /**
     * @brief transform a series of action indices
     * @param action_indices a list of action index
     * @return {*}
     */   
    static std::vector<std::vector<VehicleIntention>> indexVecToIntentionSeqVec(const std::vector<int>& action_indices);

};



/**
 * @brief transform vehicles state and lanes information to state 
 * @param nearest_lane nearest_lane for ego_vehicle
 * @return {*}
 */
class StateInterface {
 public:
    StateInterface(const ParametricLane& nearest_lane);
    StateInterface();
    ~StateInterface();

    /**
     * @brief generate state from environment information
     * @param lane_info lane information
     * @param ego_vehicle ego vehicle information
     * @param sur_vehicles surround vehicles information
     * @param state state array generated
     */
    void runOnce(const std::vector<double>& lane_info, const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& sur_vehicles, std::vector<double>* state);

    /**
     * @brief generate observations and additional state
     * @param obs_buffer observation buffer that is used to generate observations
     * @param observations the generated observations
     * @param additional_state the generated additional state
     * @return {*}
     */
    void  runOnce(const std::vector<double>& lane_info, const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& sur_vehicles, Utils::ObservationBuffer& obs_buffer, std::vector<cv::Mat>* observations, std::vector<double>* additional_state);

    /**
     * @brief transform single vehicle state
     * @param vehicle ego vehicle information
     * @return a vector represent the information
     */    
    std::vector<double> transformEgoVehicleState(const Vehicle& vehicle);

    /**
     * TODO: maybe a logic could be added here to distinct the differerce of different surround vehicles
     * @brief transform surround vehicles states
     * @param sur_vehicles information of surrounding vehicle
     * @return a vector represent the information
     */    
    std::vector<double> transformSurroundVehicleState(const std::unordered_map<int, Vehicle>& sur_vehicles);

    /**
     * @description: transform the vehicles to image vehicles, which are used to draw BEV 
     */
    std::vector<FsImageVehicle> transformSurroundImageVehicle(const std::unordered_map<int, Vehicle>& vehicles);

    StateTransformer* stf_{nullptr};
    
};

// Interface with libtorch
class TorchInterface {
 public:
    TorchInterface(const std::string& model_path);
    TorchInterface();
    ~TorchInterface();

    /**
     * @brief generate best action index from forwarding model
     * @param state state inputed to the model
     * @param action_index action generated by model
     */    
    void runOnce(const std::vector<double>& state, std::vector<int>* candi_action_indices);

    /**
     * @brief generate best action index from forwarding model
     * @param observations percepted time order observations
     * @param additional_states represent the state that also used in the network
     * @return {*}
     */    
    void runOnce(const std::vector<cv::Mat>& observations, const std::vector<double>& additional_state, torch::jit::script::Module& model, std::vector<int>* candi_action_indices);

    std::string model_path_;
};

class TrajectoryGenerator {
 public:
    using Trajectory = std::vector<Vehicle>;
    using BehaviorSequence = std::vector<VehicleBehavior>;
    using IntentionSequence = std::vector<VehicleIntention>;
    TrajectoryGenerator(BehaviorPlanner::MapInterface* map_itf, double dt = 0.4);
    TrajectoryGenerator(BehaviorPlanner::MapInterface* map_itf, const ros::Publisher& vis_pub, double dt = 0.4);
    ~TrajectoryGenerator();

    /**
     * @brief Load data for replanning
     * @param pre_reference_lane the reference in the previous planning episode
     * @param pre_ego_desired_vehicle_state the final desired vehicle state of the previous planning episode 
     * @return {*}
     */    
    void load(const ParametricLane& pre_reference_lane, const Vehicle& pre_ego_desired_vehicle_state);

    /**
     * @brief Simulate single behavior sequence
     * @param surround_vehicles surrounding vehicles information
     * @param ego_vehicle ego vehicle information
     * @param behavior_sequence execited behavior
     * @param ego_traj output trajectory (predicted states sequence)
     * @param safe is safe
     * @param cost cost value
     */    
    void simulateSingleBehaviorSequence(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const BehaviorSequence& behavior_sequence, Trajectory* ego_traj, std::unordered_map<int, Trajectory>* sur_trajs, bool* safe, double* cost, ParametricLane* target_behavior_reference_lane);

    /**
     * @brief Simulate single behavior sequence
     * @param surround_vehicles surrounding vehicles information
     * @param ego_vehicle ego vehicle information
     * @param intention_sequence execited behavior
     * @param ego_traj output trajectory (predicted states sequence)
     * @param safe is safe
     * @param cost cost value
     */    
    void simulateSingleIntentionSequence(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const IntentionSequence& intention_sequence, const int& action_index, Trajectory* ego_traj, std::unordered_map<int, Trajectory>* sur_trajs, bool* safe, double* cost, ParametricLane* target_intention_reference_lane, bool* is_lane_changed);

    /**
     * @brief simulate single behavior in a sequence 
     * @param ego_semantic_vehicle input vehicle with semantic description 
     * @param surround_semantic_vehicles input surrounding vehicles with semantic description
     * @return {*}
     */
    void simulateSingleBehavior(const SemanticVehicle& ego_semantic_vehicle, const std::unordered_map<int, SemanticVehicle>& surround_semantic_vehicles, const double& ego_desired_velocity, Vehicle& ego_vehicle_next_state, std::unordered_map<int, Vehicle>& surround_vehicles_next_states);

    /**
     * @brief simulate all candidates behavior
     * @param candi_sequences a list of candidate behavior sequence
     * @param final_action_index the selected behavior index
     * @return {*}
     */
    void simulateCandidatesBehaviorSequences(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const std::vector<BehaviorSequence>& candi_sequences, Trajectory* ego_traj, std::unordered_map<int, Trajectory>* sur_trajs, bool* safe, double* cost, ParametricLane* target_reference_lane, int* final_action_index);

    /**
     * @brief simulate all candidates behavior
     * @param candi_sequences a list of candidate behavior sequence
     * @param final_action_index the selected behavior index
     */
    void simulateCandidatesIntentionSequences(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const std::vector<IntentionSequence>& candi_sequences, const std::vector<int>& selected_idxs, Trajectory* ego_traj, std::unordered_map<int, Trajectory>* sur_trajs, bool* safe, double* cost, ParametricLane* target_reference_lane, int* final_action_index, bool* is_final_lane_changed);

    /**
     * @brief multi thread interface 
     */    
    void simulateSingleCandiBehaviorSequence(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const BehaviorSequence& executed_sequence, int index);

    /**
     * @brief simulate multiple intention sequence
     */    
    void simulateMultipleCandiIntentionSequence(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const std::vector<IntentionSequence>& candi_sequences, const int& behavior_sequence_start_index, const int& behavior_sequence_executed_num, const int& sequence_num);

    /**
     * @brief multi thread interface 
     */    
    void simulateSingleCandiIntentionSequence(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const IntentionSequence& executed_sequence, int index);

    std::vector<Trajectory> candi_ego_trajs_{};
    std::vector<std::unordered_map<int, Trajectory>> candi_sur_trajs_{};
    std::vector<bool> candi_safes_{};
    std::vector<double> candi_costs_{};
    std::vector<ParametricLane> candi_reference_lanes_{};
    std::vector<bool> candi_is_lane_changed_{};
    // DEBUG visualization
    ros::Publisher vis_pub_;

    BehaviorPlanner::MapInterface* map_itf_{nullptr};
    double dt_{0.0};
    bool with_consistence_ = false;
    ParametricLane pre_reference_lane_;
    Vehicle pre_ego_desired_vehicle_state_;
};

class HpdmPlannerCore {
 public:

    HpdmPlannerCore();
    ~HpdmPlannerCore();

    void initialize(BehaviorPlanner::MapInterface* map_itf, const ParametricLane& nearest_lane, const std::string& model_path);
    void initialize(BehaviorPlanner::MapInterface* map_itf, const ParametricLane& nearest_lane, const std::string& model_path, const ros::Publisher& vis_pub, const ros::Publisher& vis_pub_2);
    void initialize(BehaviorPlanner::MapInterface* map_itf, Utils::ObservationBuffer* observation_buffer, torch::jit::script::Module& model, const ParametricLane& nearest_lane, const ros::Publisher& vis_pub, const ros::Publisher& vis_pub_2);



    /**
     * @brief load data with consistence, which means in an replanning circle
     */    
    void load(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const std::vector<double>& lane_info, const ParametricLane& pre_reference_lane, const Vehicle& pre_ego_desired_vehicle_state, const int& pre_behavior_index);

    /**
     * @brief load data without consistence
     */   
    void load(const Vehicle& ego_vehicle, const std::unordered_map<int, Vehicle>& surround_vehicles, const std::vector<double>& lane_info);

    /**
     * @brief generate trajectories for candidate behaviors
     */   
    void generateTrajs(int lon_candidate_num);

    /**
     * @brief generate candidate behavior
     */ 
    void generateCandidateBehavior();

    /**
     * @brief generate trajectories
     */ 
    void runHpdmPlanner(int lon_candidate_num, std::vector<Vehicle>* ego_traj, std::unordered_map<int, std::vector<Vehicle>>* sur_trajs, ParametricLane* target_reference_lane, bool* safe, double* cost, bool* is_lane_changed, int* behavior_index);

    Utils::ObservationBuffer* obs_buffer_{nullptr};
    torch::jit::script::Module model_;
    BehaviorPlanner::MapInterface* map_itf_{nullptr};
    TrajectoryGenerator* traj_generator_{nullptr};
    StateInterface* state_itf_{nullptr};
    TorchInterface* torch_itf_{nullptr};
    // DEBUG visualization
    ros::Publisher vis_pub_;

    // Inputs
    Vehicle ego_vehicle_;
    std::unordered_map<int, Vehicle> surround_vehicles_;
    std::vector<double> lane_info_;
    bool with_consistence_ = false;
    ParametricLane pre_reference_lane_;
    Vehicle pre_ego_desired_vehicle_state_;
    int previous_behavior_index_{-1};

    // Middle variable
    std::set<int> candi_action_idxs_set_;
    std::vector<int> candi_action_idxs_;

    // Outputs
    std::vector<Vehicle> ego_trajectory_;
    std::unordered_map<int, std::vector<Vehicle>> sur_trajectories_;
    bool is_safe_{false};
    double policy_cost_{0.0};
    ParametricLane target_ref_lane_;
    bool is_final_lane_changed_{false};
    int current_behavior_index_{-1};
    bool behaviors_generation_success_{false};

};

} // End of namespace HpdmPlanner
